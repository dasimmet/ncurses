const std = @import("std");
const compat = @import("compat.zig");

pub fn main() !void {
    var gpa_impl = std.heap.GeneralPurposeAllocator(.{}).init;
    defer _ = gpa_impl.deinit();
    const gpa = gpa_impl.allocator();

    var arena_impl = std.heap.ArenaAllocator.init(gpa);
    defer arena_impl.deinit();
    const arena = arena_impl.allocator();
    _ = arena;

    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    std.debug.assert(args.len >= 4);
    const outpath = args[1];
    const curses_h = args[2];
    const awk = args[3];

    _ = curses_h;
    _ = awk;

    const outfile = try std.fs.cwd().createFile(outpath, .{});
    defer outfile.close();

    var outbuf: [4096]u8 = undefined;
    var output = outfile.writer(&outbuf);
    defer output.interface.flush() catch unreachable;
    const writer = &output.interface;

    try writer.print(
        \\/* This file was generated by {s} */
        \\
    , .{@src().file});

    // TODO: this actually needs to be conditional maybe?
    // original shell call:
    // ./ncurses/tinfo/MKfallback.sh $(TERMINFO) $(TERMINFO_SRC) "$(TIC_PATH)" "$(INFOCMP_PATH)" $(FALLBACK_LIST)
    try writer.writeAll(
        \\/*
        \\ * DO NOT EDIT THIS FILE BY HAND!
        \\ *
        \\ * This is a file of trivial functions generated from macro
        \\ * definitions in curses.h to satisfy the XSI Curses requirement
        \\ * that every macro also exist as a callable function.
        \\ *
        \\ * It will never be linked unless you call one of the entry
        \\ * points with its normal macro definition disabled. In that
        \\ * case, if you have no shared libraries, it will indirectly
        \\ * pull most of the rest of the library into your link image.
        \\*/
        \\
    );
}
